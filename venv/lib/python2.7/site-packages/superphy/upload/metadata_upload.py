#!/usr/bin/env python
# -*- coding: UTF-8 -*-

"""This module uploads genome metadata that has been prepared by another script and converted into a JSON format.
ijson is used to parse the JSON file because it reads from file line by line, instead of storing to memory first.

TODO: join the two workflows someday as to avoid file IO issues and to allow for parallel operation and batching

Classes:
	MetadataUploader: uploads metadata from a stored JSON object
	GenomeMetadata: stores genome metadata for uploading
"""

from collections import defaultdict
import sys
import traceback
import subprocess

from ijson.backends import YAJLImportError
try:
	import ijson.backends.yajl2 as ijson
except YAJLImportError:
	import ijson.backends.yajl as ijson
from rdflib import Graph

from Bio.Blast import NCBIWWW
from Bio import SeqIO
from Bio.Blast import NCBIXML

from _eutils import return_elink_uid, return_esearch_uid
from _sparql import check_NamedIndividual, has_ref_gene, _sparql_query
from _utils import generate_output, generate_path
from classes import PendingGenome, Gene, GeneLocation
from contig_upload import ContigUploader, ContigsWrapper
from blazegraph_upload import BlazegraphUploader

# UTF-8 is necessary to handle the encoding for non-ASCII characters in user-inputed strings (user-inputted fields are
# a big offender of this (e.g. location names)
reload(sys)
sys.setdefaultencoding("utf-8")

__author__ = "Stephen Kan"
__copyright__ = "Â© Copyright Government of Canada 2012-2015. Funded by the Government of Canada Genomics Research and Development Initiative"
__license__ = "ASL"
__version__ = "2.0"
__maintainer__ = "Stephen Kan"
__email__ = "stebokan@gmail.com"


class MetadataUploader(object):
	"""A class for parsing and uploading metadata from a specially prepared JSON file.

	TODO: link Genbank data extraction directly to MetadataUploader, so that we can avoid File IO issues.
	We may still need files if memory is insufficient; batch up metadata into files and upload files sequentially?
	"""
	def __init__(self, filename):
		"""Initializes the class with zeroed counters and containers.

		Args:
			filename (str): the relative filepath from this script
			organism (str): the SPARQL URI for the organism of interest being uploaded
		"""
		self.progress = 0
		self.error = 0
		self.filename = filename

	def upload(self):
		"""Uploads the contents of the given file by parsing it as an ijson stream.

		Prints out ending message regarding number of genomes processed and errors encountered
		"""
		with open(generate_path(self.filename), "r") as fd:
			data = ijson.parse(fd)
			self.parse_metadata(data)

		print "%d genomes parsed, %d errors occurred." % (self.progress, self.error)


	def error_logging(self, name):
		"""Records the trackback of any error messages to an log file so that if any are encountered, the log file will
		retain pertinent information for debugging

		Args:
			name(str): The genome that is currently being uploaded
		"""
		self.error += 1
		with open(generate_path("outputs/errors.txt"), "a") as f:
			f.write("%s \n\n %s \n ================================ \n\n" % (name, traceback.format_exc()))
		print "Error %d occurred." % self.error


class MetaData(object):
	"""
	A container class used to store information about an entity (such as a genome or gene) before uploading to Blazegraph.
	Refactored out because the data was acting as a data clump.
	"""
	def __init__(self, name):
		"""Initializes the class with appropriate fields and variables being created

		Args:
			name(str): The name of the entity
		"""
		self.name = name
		self.dict = defaultdict(set)

	def add_parameter(self, key, value):
		"""Adds a new genome data entry to the class.

		Args:
			key(str): The type of data being added
			value(str): The value of the data
		"""
		self.dict[key].add(value)

	def build_kwargs(self):
		"""Converts all data stored by the class into a dict used for creating a superphy.uploader.classes.(some entity) instance

		Returns: the kwargs dict to be used as an argument in the constructor of classes.(some entity)
		"""
		kwargs = {'name':self.name}

		for key, value in self.dict.iteritems():
			kwargs.update({key: value})

		return kwargs


class GenomeMetadataUploader(MetadataUploader):
	"""A class for parsing and uploading genome metadata from a specially prepared JSON file.

	TODO: link Genbank data extraction directly to MetadataUploader, so that we can avoid File IO issues.
	We may still need files if memory is insufficient; batch up metadata into files and upload files sequentially?
	"""

	def __init__(self, filename, organism):
		super(GenomeMetadataUploader, self).__init__(filename)
		self.organism = organism

	def parse_metadata(self, data):
		"""Takes in data from an ijson stream and parses for genomic metadata based on attached tags

		Args:
			data: an ijson stream created from an open file
		"""
		metadata = None
		for prefix, event, value in data:
			if ("." not in prefix) and (prefix is not "") and (event == "start_map"):
				self.add_to_graph(metadata)
				metadata = GenomeMetadata(prefix, self.organism)

			if prefix.endswith(".displayname"):
				metadata.add_parameter(prefix.split(".", 3)[1], value)
		self.add_to_graph(metadata)

	def add_to_graph(self, metadata):
		"""Attempts to upload data to Blazegraph via conversion to RDF and turtle. Tracks errors made during this process
		as it likely has to do with either missing curated data, a blocked or inaccessible NCBI site, and issues with
		formatting and information availability.

		Args:
			metadata (GenomeMetadata): a GenomeMetadata object used to store relevant key-value pairs from the parse
		"""
		if metadata:
			try:
				self.progress += 1
				print "%d: downloading files" % self.progress
				self.create_pending_genome(metadata)
			except Exception as e:
				self.error_logging(metadata.name)

	def create_pending_genome(self, metadata):
		"""Creates a PendingGenome object to export the data out in the turtle format with the appropriate RDF tags and
		uploads it into Blazegraph.

		Args:
			metadata(GenomeMetadata): An instance that contains metadata pertaining to an individual genome
		"""
		g = Graph()
		name = metadata.name

		if check_NamedIndividual(name):
			print "%s already in Blazegraph." % name
		else:
			self.get_ncbi_ids(metadata)
			kwargs = metadata.build_kwargs()
			PendingGenome(g, **kwargs).rdf()
			BlazegraphUploader().upload_data(generate_output(g))

	def get_ncbi_ids(self, metadata):
		"""Gets the bioproject and biosample ids linked to a genome's accession ID (pertinent to NCBI sequences only)

		Args:
			metadata(GenomeMetadata): An instance that contains metadata pertaining to an individual genome
		"""
		nuccore_id = return_esearch_uid("nuccore", metadata.dict["accession"])

		for item in return_elink_uid("nuccore", "bioproject", nuccore_id):
			metadata.add_parameter("bioproject", item)

		for item in return_elink_uid("nuccore", "biosample", nuccore_id):
			metadata.add_parameter("biosample", item)


class GenomeMetadata(MetaData):
	"""
	A container class used to store information about each individual genome before uploading to Blazegraph.
	Refactored out because the data was acting as a data clump.
	"""
	def __init__(self, name, organism):
		"""Initializes the class with appropriate fields and variables being created

		Args:
			name(str): The name of the genome this class represents
			organism(str): The organism from which the genome came from.
		"""
		super(GenomeMetadata, self).__init__(name)
		self.organism = organism
		self.dict = defaultdict(set)
		self.dict['accession'].add(name)

	def build_kwargs(self):
		"""Converts all data stored by the class into a dict used for creating a superphy.uploader.classes.Genome instance

		Returns: the kwargs dict to be used as an argument in the constructor of classes.Genome
		"""
		kwargs = {'name':self.name, 'organism':self.organism}

		for key, value in self.dict.iteritems():
			if key == "serotype":
				kwargs.update(self.get_serotypes(value))

			else:
				kwargs.update({key: value})

		return kwargs


	def get_serotypes(self, serotypes):
		"""Extracts information about O and H type serotype from a serotype data field

		Args:
			serotypes(str): a O???:H?? serotype string where the ??? indicates numbers of interest

		Returns: a dict containing the extracted information
		"""
		Otype = None
		Htype = None

		for serotype in serotypes:
			if "NT" in serotype or "R" in serotype:
				Otype = "NT"
			else:
				Otype = serotype.split(":")[0][1:]

			if "NM" in serotype:
				Htype = "NM"
			elif "NA" in serotype:
				Htype = None
			else:
				Htype = serotype.split(":")[1][1:]

		return {"Otype": Otype, "Htype": Htype}


class GeneMetaDataUploader(MetadataUploader):
	"""A class for parsing and uploading gene metadata from an XML or fasta file.

	"""

	def __init__(self, filename):
		super(GeneMetaDataUploader, self).__init__(filename)
		self.dict = {}


	def complete_genome(self, contig, desc):
		"""
		Returns a string of the accession number with "_closed" appended at the end if it is complete.

		Args:
			contig(str): an accession number for a contig 
			desc(str): a description of a particular contig/genome.
		"""
		name = contig

		if "complete" in desc:
			contig = contig + "_closed"

		return contig


	def add_contig(self, gene_name, contig):
		"""
		Adds contig to self.dict to count the number of times a gene has appeared on a certain contig.

		Args:
			gene_name(str): name of the gene
			contig(str): accession name of the contig
		"""

		if gene_name in self.dict and contig in self.dict[gene_name]:
			self.dict[gene_name][contig] += 1
		else:
			self.dict[gene_name] = {}
			self.dict[gene_name][contig] = 0


	def parse_virulence_factors(self):
		"""
		Takes the XML result from the virulence factor blast and adds metadata to the GeneMetadata instance. 
		Also calls method to upload sequence information for genomes matched that are not already in the Blazegraph

		"""

		metadata = None
		nonuploaded_genomes = []

		with open(generate_path("samples/superphy_vf.xml")) as result_handle:
			blast_records = NCBIXML.parse(result_handle)

			E_VALUE_THRESH = 0.04

			for blast_record in blast_records:
				for alignment in blast_record.alignments[:1]:
					for hsp in alignment.hsps:
						if hsp.expect < E_VALUE_THRESH and hsp.gaps == 0 and int(hsp.score) == hsp.identities:
							gene_name = blast_record.query.split("|")[0]

							# gene has multiple names
							if "/" in gene_name:
								gene_name = gene_name.split("/")[0]

							contig_accession = alignment.title.split("|")[3].split(".")[0]
							contig_name = self.complete_genome(contig_accession, alignment.title.split("|")[4])

							self.add_contig(gene_name, contig_name)

							if (not check_NamedIndividual(contig_name)) and ((contig_accession, contig_accession) not in nonuploaded_genomes):
								nonuploaded_genomes.append((contig_accession, contig_accession))

							name = gene_name + "_" + contig_name + "_" + str(self.dict[gene_name][contig_name])
							begin = hsp.sbjct_start
							end = str(int(hsp.sbjct_start) + int(hsp.score) - 1)
							ref_gene = False

							if not has_ref_gene(gene_name):
								ref_gene = True

							self.create_gene_location(name, gene_name, contig_name, begin, end, hsp.sbjct, ref_gene)
		print nonuploaded_genomes
		#ContigUploader().upload_missing_contigs(nonuploaded_genomes)


	def add_to_graph(self, metadata):
		"""Attempts to upload data to Blazegraph via conversion to RDF and turtle. Tracks errors made during this process
		as it likely has to do with either missing curated data, a blocked or inaccessible NCBI site, and issues with
		formatting and information availability.

		Args:
			metadata (GeneMetadata): a GeneMetadata object used to store relevant key-value pairs from the parse
		"""
		if metadata:
			try:
				self.progress += 1
				print "%d: downloading files" % self.progress
				self.create_gene(metadata)
			except Exception as e:
				self.error_logging(metadata.name)


	def create_gene(self, metadata):
		"""Creates a Gene object to export the data out in the turtle format with the appropriate RDF tags and
		uploads it into Blazegraph.

		Args:
			metadata(GeneMetadata): An instance that contains metadata pertaining to an individual gene
		"""
		g = Graph()
		name = metadata.name

		# if check_NamedIndividual(name):
		# 	print "%s already in Blazegraph." % name
		# else:
		kwargs = metadata.build_kwargs()
		Gene(g, **kwargs).rdf()
		BlazegraphUploader().upload_data(generate_output(g))


	def create_gene_location(self, name, gene, contig, begin, end, seq, ref_gene):
		""" Creates a GeneLocation object to export the data in turtle format with the appropriate RDF tags and
		uploads it to Blazegraph.

		Args:
			name (str): gene name  + "_" + contig name + "_" + occurence number
            gene (str): the name of the gene
            contig (str): name of the contig its found in
            begin (str): the beginning position of the gene in contig
            end (str): the end position of the gene in contig
            seq (str): the sequence of the gene on the contig
            is_ref_gene (boolean): signifies whether this is the reference gene location for a particular gene
		"""

		if check_NamedIndividual(name):
			print "%s already in Blazegraph." % name
		else:
			g = Graph()
			GeneLocation(g, name, gene, contig, begin, end, seq, ref_gene).rdf()
			BlazegraphUploader().upload_data(generate_output(g))


	def get_reference_genes(self):
		"""
		Returns a list of all the reference gene instances and their sequences for analysis (from Blazegraph)
		"""

		results = _sparql_query(
			'PREFIX : <https://github.com/superphy#>\n'
			'PREFIX gfvo: <http://www.biointerchange.org/gfvo#>\n'
			'PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n'
			'PREFIX faldo: <http://biohackathon.org/resource/faldo#>\n'
			'SELECT ?s ?seq WHERE { ?s rdf:type faldo:Region . ?s rdf:type :reference_gene . ?s :has_sequence ?seq .}'
		)

		return ((result["s"]["value"].rsplit("#", 1)[1], result["seq"]["value"])
				for result in results["results"]["bindings"])


	def create_db(self):
		"""
		Creates a nucleotide database from self.filename for comparing against the reference genes in Blazegraph.
		"""

		subprocess.call("../../blast/ncbi-blast-2.3.0+/bin/makeblastdb -dbtype nucl -title genome_db -out genome_db -in %s" 
						% self.filename, shell=True)


	def create_fasta(self, reference_genes):
		"""Writes a FASTA sequence to a file for use by the command line version of BLAST. Obtains nucleotide data from
		the sequence data object used to initialize the validator and writes each entry as a separate FASTA object.
		"""
		with open(generate_path("tmp/ref_sequences.fasta"), "w") as f:
			for (location_name, seq) in reference_genes:
				f.write(">%s\n%s\n" %(location_name, seq))


	def blastn_commandline(self, db):
		"""
		Runs the command line blastn on the reference gene sequences using the supplied database.
		Outputs the results to tmp/results.xml

		Args:
			db(str): A file path to a database used for blast comparison.
		"""
		command = generate_path("../../blast/ncbi-blast*/bin/blastn")
		fasta = generate_path("tmp/ref_sequences.fasta")
		db = generate_path(db)
		results = generate_path("tmp/results.xml")

		subprocess.call("%s -query %s -db %s -outfmt 5 -out %s -best_hit_score_edge 0.05 -best_hit_overhang 0.1"
						 % (command, fasta, db, results),
						shell=True)


	def parse_result(self):
		"""
		Takes the XML result from the virulence factor blast and adds metadata to the GeneMetadata instance. 
		Also calls method to upload sequence information for genomes matched that are not already in Blazegraph

		"""

		metadata = None

		with open(generate_path("tmp/results.xml")) as result_handle:
			blast_records = NCBIXML.parse(result_handle)

			E_VALUE_THRESH = 0.04

			for blast_record in blast_records:
				for alignment in blast_record.alignments:
					for hsp in alignment.hsps:
						if hsp.expect < E_VALUE_THRESH:
							gene_name = blast_record.query.split("_")[0]

							contig_accession = alignment.title.split("|")[5].split(".")[0]
							contig_name = self.complete_genome(contig_accession, alignment.title.split("|")[6])
							print "desc:", alignment.title
							print contig_accession
							print "contig name:", contig_name

							name = gene_name + "_" + contig_name + "_" + str(counter)
							begin = hsp.sbjct_start
							end = str(int(hsp.sbjct_start) + int(hsp.score) - 1)
							ref_gene = False

							self.create_gene_location(name, gene_name, contig_name, begin, end, hsp.sbjct, ref_gene)


class GeneMetadata(MetaData):
	"""
	A container class used to store information about an individual gene before uploading to Blazegraph.
	"""
	def __init__(self, name):
		"""Initializes the class with appropriate fields and variables being created

		Args:
			name(str): Name of the gene that this class represents
		"""
		self.name = name
		self.dict = defaultdict(set)
		self.dict["name"] = name

	def build_kwargs(self):
		"""Converts all data stored by the class into a dict used for creating a superphy.uploader.classes.Genome instance

		Returns: the kwargs dict to be used as an argument in the constructor of classes.Genome
		"""
		kwargs = {'name': self.name}

		for key, value in self.dict.iteritems():
			kwargs.update({key: value})

		return kwargs


#MetadataUploader("samples/meta_pipe_result.json", "ecoli").upload()

###### For Testing purposes ######

if __name__ == "__main__":
 	# For genome testing
	# md = GenomeMetadataUploader("samples/4_genome.json", "Human")
	# md.upload()

 	# For gene testing
	gmd = GeneMetaDataUploader('samples/superphy_vf.xml')
	gmd.parse_virulence_factors()
	reference_genes = gmd.get_reference_genes()
	gmd.create_fasta(reference_genes)
	gmd.blastn_commandline("../../blast/ncbi-blast-2.3.0+/bin/genome_db")
	gmd.parse_result()